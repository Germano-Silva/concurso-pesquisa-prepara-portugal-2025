# -*- coding: utf-8 -*-
"""DP-01-A.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Sd2iujzayzlEyIDl7QetR4tVV7S_9XXs
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script para processar dados do INE sobre popula√ß√£o estrangeira em Portugal
e criar modelo de dados normalizado baseado no Diagrama Entidade-Relacionamento otimizado.

Autor: Sistema de An√°lise de Dados
Data: 2024
Fonte: INE - Censos 2021, Popula√ß√£o Estrangeira
"""

import pandas as pd
import numpy as np
import os
import re
from pathlib import Path
import warnings

warnings.filterwarnings('ignore')

class ProcessadorDadosINE:
    """Classe principal para processar dados do INE e criar modelo relacional normalizado."""

    def __init__(self):
        self.dados_originais = {}
        self.tabelas_normalizadas = {}
        self.contadores_id = {
            'populacao_id': 1,
            'nacionalidade_id': 1,
            'localidade_id': 1,
            'sexo_id': 1,
            'grupoetario_id': 1,
            'populacao_nacional_id': 1,
            'populacao_nacional_sexo_id': 1,
            'populacao_local_id': 1,
            'populacao_local_nacional_id': 1,
            'populacao_grupoetario_id': 1,
            'evolucao_id': 1,
            'nacionalidade_principal_id': 1,
            'distribuicao_geo_id': 1
        }

    def carregar_dados_originais(self):
        """Carrega os arquivos CSV originais do INE."""
        print("üìä Carregando dados originais do INE...")

        # Caminhos dos arquivos
        arquivos = {
            'q1_1': f"/content/Q1.1.csv",  # Nacionalidade e sexo, 2011-2021
            'q1_2': f"/content/Q1.2.csv",  # Nacionalidade e localiza√ß√£o
            'q1_3': f"/content/Q1.3.csv"   # Nacionalidade e grupos et√°rios
        }

        for nome, caminho in arquivos.items():
            try:
                # Carrega com encoding adequado para caracteres especiais
                df = pd.read_csv(caminho, encoding='latin1') # Changed encoding to 'latin1'
                self.dados_originais[nome] = df
                print(f"‚úÖ {nome}: {df.shape[0]} linhas, {df.shape[1]} colunas")
            except Exception as e:
                print(f"‚ùå Erro ao carregar {nome}: {e}")

        print(f"üì• {len(self.dados_originais)} arquivos carregados com sucesso\n")

    def limpar_dados_nacionalidade_sexo(self):
        """Processa dados do arquivo Q1.1 - Nacionalidade e Sexo."""
        print("üßπ Processando dados de nacionalidade e sexo (Q1.1)...")

        df = self.dados_originais['q1_1'].copy()

        # Remove linhas de cabe√ßalho e rodap√©
        df = df.dropna(subset=[df.columns[0]])
        df = df[~df.iloc[:, 0].str.contains('Quadro|Fonte:|^,', na=False)]

        # Identifica linhas com dados v√°lidos
        linhas_dados = []
        for idx, row in df.iterrows():
            primeira_coluna = str(row.iloc[0]).strip()
            if primeira_coluna and primeira_coluna not in ['', 'nan'] and not primeira_coluna.startswith(','):
                # Extrai dados das colunas num√©ricas
                try:
                    # 2021: HM, H, M
                    hm_2021 = self._clean_number(row.iloc[1]) if len(row) > 1 else 0
                    h_2021 = self._clean_number(row.iloc[2]) if len(row) > 2 else 0
                    m_2021 = self._clean_number(row.iloc[3]) if len(row) > 3 else 0

                    # 2011: HM, H, M
                    hm_2011 = self._clean_number(row.iloc[4]) if len(row) > 4 else 0
                    h_2011 = self._clean_number(row.iloc[5]) if len(row) > 5 else 0
                    m_2011 = self._clean_number(row.iloc[6]) if len(row) > 6 else 0

                    # Varia√ß√£o: HM, H, M
                    var_hm = self._clean_number(row.iloc[7], is_percentage=True) if len(row) > 7 else 0
                    var_h = self._clean_number(row.iloc[8], is_percentage=True) if len(row) > 8 else 0
                    var_m = self._clean_number(row.iloc[9], is_percentage=True) if len(row) > 9 else 0

                    if hm_2021 > 0 or hm_2011 > 0:  # Pelo menos um valor v√°lido
                        linhas_dados.append({
                            'nacionalidade': primeira_coluna,
                            'hm_2021': hm_2021,
                            'h_2021': h_2021,
                            'm_2021': m_2021,
                            'hm_2011': hm_2011,
                            'h_2011': h_2011,
                            'm_2011': m_2011,
                            'variacao_hm': var_hm,
                            'variacao_h': var_h,
                            'variacao_m': var_m
                        })
                except:
                    continue

        self.dados_originais['q1_1_limpo'] = pd.DataFrame(linhas_dados)
        print(f"‚úÖ Q1.1 processado: {len(linhas_dados)} nacionalidades identificadas")

    def limpar_dados_localidade(self):
        """Processa dados do arquivo Q1.2 - Localiza√ß√£o geogr√°fica."""
        print("üßπ Processando dados de localiza√ß√£o geogr√°fica (Q1.2)...")

        df = self.dados_originais['q1_2'].copy()

        # Remove cabe√ßalhos e linhas inv√°lidas
        df = df.dropna(subset=[df.columns[0]])
        df = df[~df.iloc[:, 0].str.contains('Quadro|Fonte:|^,|NUTS', na=False)]

        linhas_dados = []
        for idx, row in df.iterrows():
            localidade = str(row.iloc[0]).strip()
            if localidade and localidade not in ['', 'nan']:
                try:
                    # Extrai dados populacionais
                    total_pop = self._clean_number(row.iloc[1]) if len(row) > 1 else 0
                    nac_portuguesa = self._clean_number(row.iloc[2]) if len(row) > 2 else 0
                    nac_estrangeira = self._clean_number(row.iloc[3]) if len(row) > 3 else 0
                    apatridas = self._clean_number(row.iloc[4]) if len(row) > 4 else 0

                    if total_pop > 0:
                        dados_linha = {
                            'localidade': localidade,
                            'total_populacao': total_pop,
                            'populacao_portuguesa': nac_portuguesa,
                            'populacao_estrangeira': nac_estrangeira,
                            'apatridas': apatridas
                        }

                        # Adiciona dados das principais nacionalidades (colunas 5-19)
                        nacionalidades_principais = [
                            'Brasil', 'Angola', 'Cabo Verde', 'Reino Unido', 'Ucr√¢nia',
                            'Fran√ßa', 'China', 'Guin√©-Bissau', '√çndia', 'Rom√™nia',
                            'It√°lia', 'Nepal', 'Espanha', 'Alemanha', 'S√£o Tom√© e Pr√≠ncipe'
                        ]

                        for i, nac in enumerate(nacionalidades_principais):
                            col_idx = 5 + i
                            if len(row) > col_idx:
                                dados_linha[nac] = self._clean_number(row.iloc[col_idx])

                        linhas_dados.append(dados_linha)

                except:
                    continue

        self.dados_originais['q1_2_limpo'] = pd.DataFrame(linhas_dados)
        print(f"‚úÖ Q1.2 processado: {len(linhas_dados)} localidades identificadas")

    def limpar_dados_grupo_etario(self):
        """Processa dados do arquivo Q1.3 - Grupos et√°rios."""
        print("üßπ Processando dados de grupos et√°rios (Q1.3)...")

        df = self.dados_originais['q1_3'].copy()

        # Remove cabe√ßalhos e rodap√©
        df = df.dropna(subset=[df.columns[0]])
        df = df[~df.iloc[:, 0].str.contains('Quadro|Fonte:', na=False)]

        linhas_dados = []
        for idx, row in df.iterrows():
            nacionalidade = str(row.iloc[0]).strip()
            if nacionalidade and nacionalidade not in ['', 'nan', 'Grupo et√°rio', 'Total']:
                try:
                    total_pop = self._clean_number(row.iloc[1]) if len(row) > 1 else 0

                    # Grupos et√°rios absolutos
                    g_0_14 = self._clean_number(row.iloc[2]) if len(row) > 2 else 0
                    g_15_24 = self._clean_number(row.iloc[3]) if len(row) > 3 else 0
                    g_25_64 = self._clean_number(row.iloc[4]) if len(row) > 4 else 0
                    g_65_mais = self._clean_number(row.iloc[5]) if len(row) > 5 else 0

                    # Grupos et√°rios percentuais
                    p_0_14 = self._clean_number(row.iloc[6], is_percentage=True) if len(row) > 6 else 0
                    p_15_24 = self._clean_number(row.iloc[7], is_percentage=True) if len(row) > 7 else 0
                    p_25_64 = self._clean_number(row.iloc[8], is_percentage=True) if len(row) > 8 else 0
                    p_65_mais = self._clean_number(row.iloc[9], is_percentage=True) if len(row) > 9 else 0

                    # Idades m√©dias
                    idade_media_hm = self._clean_number(row.iloc[10], is_percentage=True) if len(row) > 10 else 0
                    idade_media_h = self._clean_number(row.iloc[11], is_percentage=True) if len(row) > 11 else 0
                    idade_media_m = self._clean_number(row.iloc[12], is_percentage=True) if len(row) > 12 else 0

                    if total_pop > 0:
                        linhas_dados.append({
                            'nacionalidade': nacionalidade,
                            'total_populacao': total_pop,
                            'grupo_0_14': g_0_14,
                            'grupo_15_24': g_15_24,
                            'grupo_25_64': g_25_64,
                            'grupo_65_mais': g_65_mais,
                            'perc_0_14': p_0_14,
                            'perc_15_24': p_15_24,
                            'perc_25_64': p_25_64,
                            'perc_65_mais': p_65_mais,
                            'idade_media_hm': idade_media_hm,
                            'idade_media_h': idade_media_h,
                            'idade_media_m': idade_media_m
                        })

                except:
                    continue

        self.dados_originais['q1_3_limpo'] = pd.DataFrame(linhas_dados)
        print(f"‚úÖ Q1.3 processado: {len(linhas_dados)} nacionalidades com dados et√°rios")

    def _clean_number(self, value, is_percentage=False):
        """Limpa e converte valores num√©ricos."""
        if pd.isna(value) or value == '':
            return 0

        # Convert to string and clean
        str_val = str(value).strip()

        # Remove espa√ßos, v√≠rgulas como separadores de milhares
        str_val = str_val.replace(' ', '').replace(',', '')

        # Trata percentuais
        if is_percentage and '%' in str_val:
            str_val = str_val.replace('%', '')

        try:
            # Tenta converter para float
            if '.' in str_val or ',' in str_val:
                # Substitui v√≠rgula por ponto para decimais
                str_val = str_val.replace(',', '.')
                return float(str_val)
            else:
                return int(str_val)
        except:
            return 0

    def criar_tabela_populacao_residente(self):
        """Cria a tabela Popula√ß√£oResidente (entidade principal)."""
        print("üèóÔ∏è  Criando tabela Popula√ß√£oResidente...")

        tabela = []

        # Adiciona dados de 2021 e 2011
        for ano in [2021, 2011]:
            populacao_id = self.contadores_id['populacao_id']

            if ano == 2021:
                total_pop = self.dados_originais['q1_1_limpo']['hm_2021'].sum()
            else:
                total_pop = self.dados_originais['q1_1_limpo']['hm_2011'].sum()

            tabela.append({
                'populacao_id': populacao_id,
                'total_populacao': total_pop,
                'ano_referencia': ano
            })

            self.contadores_id['populacao_id'] += 1

        self.tabelas_normalizadas['PopulacaoResidente'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela Popula√ß√£oResidente criada: {len(tabela)} registros")

    def criar_tabela_nacionalidade(self):
        """Cria a tabela Nacionalidade."""
        print("üèóÔ∏è  Criando tabela Nacionalidade...")

        # Extrai nacionalidades √∫nicas de todos os datasets
        nacionalidades_set = set()

        for df_name in ['q1_1_limpo', 'q1_3_limpo']:
            if df_name in self.dados_originais:
                nacs = self.dados_originais[df_name]['nacionalidade'].unique()
                nacionalidades_set.update(nacs)

        tabela = []
        for nac in sorted(nacionalidades_set):
            if nac and nac.strip():
                nacionalidade_id = self.contadores_id['nacionalidade_id']

                # Determina continente baseado na nacionalidade
                continente = self._determinar_continente(nac)

                # Cria c√≥digo do pa√≠s (simplificado)
                codigo_pais = self._criar_codigo_pais(nac)

                tabela.append({
                    'nacionalidade_id': nacionalidade_id,
                    'nome_nacionalidade': nac.strip(),
                    'codigo_pais': codigo_pais,
                    'continente': continente
                })

                self.contadores_id['nacionalidade_id'] += 1

        self.tabelas_normalizadas['Nacionalidade'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela Nacionalidade criada: {len(tabela)} registros")

    def criar_tabela_localidade(self):
        """Cria a tabela Localidade."""
        print("üèóÔ∏è  Criando tabela Localidade...")

        if 'q1_2_limpo' not in self.dados_originais:
            print("‚ùå Dados de localidade n√£o dispon√≠veis")
            return

        df_localidade = self.dados_originais['q1_2_limpo']
        tabela = []

        for _, row in df_localidade.iterrows():
            localidade_id = self.contadores_id['localidade_id']
            localidade = row['localidade']

            # Determina n√≠vel administrativo
            nivel_admin = self._determinar_nivel_administrativo(localidade)

            # Cria c√≥digo da regi√£o
            codigo_regiao = self._criar_codigo_regiao(localidade)

            tabela.append({
                'localidade_id': localidade_id,
                'nome_localidade': localidade,
                'nivel_administrativo': nivel_admin,
                'codigo_regiao': codigo_regiao
            })

            self.contadores_id['localidade_id'] += 1

        self.tabelas_normalizadas['Localidade'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela Localidade criada: {len(tabela)} registros")

    def criar_tabela_sexo(self):
        """Cria a tabela Sexo."""
        print("üèóÔ∏è  Criando tabela Sexo...")

        tipos_sexo = ['HM', 'H', 'M']  # HM = Ambos os sexos, H = Homens, M = Mulheres
        tabela = []

        for tipo in tipos_sexo:
            sexo_id = self.contadores_id['sexo_id']
            tabela.append({
                'sexo_id': sexo_id,
                'tipo_sexo': tipo
            })
            self.contadores_id['sexo_id'] += 1

        self.tabelas_normalizadas['Sexo'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela Sexo criada: {len(tabela)} registros")

    def criar_tabela_grupo_etario(self):
        """Cria a tabela GrupoEtario."""
        print("üèóÔ∏è  Criando tabela GrupoEtario...")

        grupos = [
            {'faixa': '0-14', 'descricao': 'Crian√ßas e jovens'},
            {'faixa': '15-24', 'descricao': 'Jovens adultos'},
            {'faixa': '25-64', 'descricao': 'Adultos em idade ativa'},
            {'faixa': '65+', 'descricao': 'Idosos'}
        ]

        tabela = []
        for grupo in grupos:
            grupoetario_id = self.contadores_id['grupoetario_id']
            tabela.append({
                'grupoetario_id': grupoetario_id,
                'faixa_etaria': grupo['faixa'],
                'descricao': grupo['descricao']
            })
            self.contadores_id['grupoetario_id'] += 1

        self.tabelas_normalizadas['GrupoEtario'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela GrupoEtario criada: {len(tabela)} registros")

    def criar_tabela_populacao_por_nacionalidade(self):
        """Cria a tabela de relacionamento Popula√ß√£oPorNacionalidade."""
        print("üèóÔ∏è  Criando tabela Popula√ß√£oPorNacionalidade...")

        df_nac_sexo = self.dados_originais['q1_1_limpo']
        tabela = []

        # Mapeia nacionalidades para IDs
        nac_to_id = self._criar_mapa_nacionalidade_id()
        pop_to_id = {2021: 1, 2011: 2}  # IDs da tabela Popula√ß√£oResidente

        for _, row in df_nac_sexo.iterrows():
            nacionalidade = row['nacionalidade']
            if nacionalidade in nac_to_id:
                nacionalidade_id = nac_to_id[nacionalidade]

                # Dados para 2021
                if row['hm_2021'] > 0:
                    populacao_nacional_id = self.contadores_id['populacao_nacional_id']
                    total_2021 = row['hm_2021']
                    masc_2021 = row['h_2021']
                    fem_2021 = row['m_2021']

                    # Calcula percentagem sobre o total de estrangeiros
                    total_estrangeiros_2021 = df_nac_sexo['hm_2021'].sum()
                    perc_total = (total_2021 / total_estrangeiros_2021 * 100) if total_estrangeiros_2021 > 0 else 0

                    tabela.append({
                        'populacao_nacional_id': populacao_nacional_id,
                        'nacionalidade_id': nacionalidade_id,
                        'populacao_id': pop_to_id[2021],
                        'populacao_total': total_2021,
                        'masculino': masc_2021,
                        'feminino': fem_2021,
                        'percentagem_total': round(perc_total, 2)
                    })

                    self.contadores_id['populacao_nacional_id'] += 1

                # Dados para 2011
                if row['hm_2011'] > 0:
                    populacao_nacional_id = self.contadores_id['populacao_nacional_id']
                    total_2011 = row['hm_2011']
                    masc_2011 = row['h_2011']
                    fem_2011 = row['m_2011']

                    # Calcula percentagem sobre o total de estrangeiros
                    total_estrangeiros_2011 = df_nac_sexo['hm_2011'].sum()
                    perc_total = (total_2011 / total_estrangeiros_2011 * 100) if total_estrangeiros_2011 > 0 else 0

                    tabela.append({
                        'populacao_nacional_id': populacao_nacional_id,
                        'nacionalidade_id': nacionalidade_id,
                        'populacao_id': pop_to_id[2011],
                        'populacao_total': total_2011,
                        'masculino': masc_2011,
                        'feminino': fem_2011,
                        'percentagem_total': round(perc_total, 2)
                    })

                    self.contadores_id['populacao_nacional_id'] += 1

        self.tabelas_normalizadas['PopulacaoPorNacionalidade'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela Popula√ß√£oPorNacionalidade criada: {len(tabela)} registros")

    def criar_tabela_populacao_por_grupo_etario(self):
        """Cria a tabela de relacionamento Popula√ß√£oPorGrupoEtario."""
        print("üèóÔ∏è  Criando tabela Popula√ß√£oPorGrupoEtario...")

        if 'q1_3_limpo' not in self.dados_originais:
            print("‚ùå Dados de grupo et√°rio n√£o dispon√≠veis")
            return

        df_etario = self.dados_originais['q1_3_limpo']
        tabela = []

        # Mapas de IDs
        nac_to_id = self._criar_mapa_nacionalidade_id()
        grupo_to_id = {
            'grupo_0_14': 1,
            'grupo_15_24': 2,
            'grupo_25_64': 3,
            'grupo_65_mais': 4
        }

        for _, row in df_etario.iterrows():
            nacionalidade = row['nacionalidade']
            if nacionalidade in nac_to_id:
                nacionalidade_id = nac_to_id[nacionalidade]

                # Para cada grupo et√°rio
                for grupo_col, grupo_id in grupo_to_id.items():
                    populacao_grupo = row[grupo_col]
                    if populacao_grupo > 0:
                        populacao_grupoetario_id = self.contadores_id['populacao_grupoetario_id']

                        # Calcula percentagem
                        perc_col = grupo_col.replace('grupo_', 'perc_').replace('_mais', '_mais')
                        if grupo_col == 'grupo_65_mais':
                            perc_col = 'perc_65_mais'

                        percentagem_grupo = row.get(perc_col, 0)

                        # Idade m√©dia (usa m√©dia geral por nacionalidade)
                        idade_media = row.get('idade_media_hm', 0)

                        tabela.append({
                            'populacao_grupoetario_id': populacao_grupoetario_id,
                            'populacao_id': 1,  # Refer√™ncia para 2021
                            'grupoetario_id': grupo_id,
                            'nacionalidade_id': nacionalidade_id,
                            'populacao_grupo': populacao_grupo,
                            'percentagem_grupo': percentagem_grupo,
                            'idade_media': idade_media
                        })

                        self.contadores_id['populacao_grupoetario_id'] += 1

        self.tabelas_normalizadas['PopulacaoPorGrupoEtario'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela Popula√ß√£oPorGrupoEtario criada: {len(tabela)} registros")

    def criar_tabela_evolucao_temporal(self):
        """Cria a tabela EvolucaoTemporal."""
        print("üèóÔ∏è  Criando tabela EvolucaoTemporal...")

        df_nac_sexo = self.dados_originais['q1_1_limpo']
        tabela = []

        nac_to_id = self._criar_mapa_nacionalidade_id()

        for _, row in df_nac_sexo.iterrows():
            nacionalidade = row['nacionalidade']
            if nacionalidade in nac_to_id and row['hm_2011'] > 0 and row['hm_2021'] > 0:
                evolucao_id = self.contadores_id['evolucao_id']
                nacionalidade_id = nac_to_id[nacionalidade]

                pop_2011 = row['hm_2011']
                pop_2021 = row['hm_2021']

                variacao_absoluta = pop_2021 - pop_2011
                variacao_percentual = row['variacao_hm']

                # Taxa de crescimento anual composta
                anos = 2021 - 2011
                if pop_2011 > 0:
                    taxa_crescimento = ((pop_2021 / pop_2011) ** (1/anos) - 1) * 100
                else:
                    taxa_crescimento = 0

                tabela.append({
                    'evolucao_id': evolucao_id,
                    'nacionalidade_id': nacionalidade_id,
                    'populacao_id': 2,  # Base 2011
                    'ano_inicio': 2011,
                    'populacao_inicio': pop_2011,
                    'variacao_absoluta': variacao_absoluta,
                    'variacao_percentual': variacao_percentual,
                    'taxa_crescimento': round(taxa_crescimento, 2)
                })

                self.contadores_id['evolucao_id'] += 1

        self.tabelas_normalizadas['EvolucaoTemporal'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela EvolucaoTemporal criada: {len(tabela)} registros")

    def criar_tabela_nacionalidade_principal(self):
        """Cria a tabela NacionalidadePrincipal para ranking das principais nacionalidades."""
        print("üèóÔ∏è  Criando tabela NacionalidadePrincipal...")

        df_nac_sexo = self.dados_originais['q1_1_limpo']
        tabela = []

        nac_to_id = self._criar_mapa_nacionalidade_id()

        # Filtra principais nacionalidades (exclui portuguesas e totais)
        principais_nacs = df_nac_sexo[
            ~df_nac_sexo['nacionalidade'].str.contains(
                'Popula√ß√£o|Nacionalidade portuguesa|Ap√°tridas',
                na=False, case=False
            )
        ].copy()

        # Ordena por popula√ß√£o 2021 decrescente
        principais_nacs = principais_nacs.sort_values('hm_2021', ascending=False)

        for posicao, (_, row) in enumerate(principais_nacs.iterrows(), 1):
            if posicao <= 15:  # Top 15 nacionalidades
                nacionalidade = row['nacionalidade']
                if nacionalidade in nac_to_id:
                    nacionalidade_principal_id = self.contadores_id['nacionalidade_principal_id']
                    nacionalidade_id = nac_to_id[nacionalidade]

                    pop_2021 = row['hm_2021']
                    pop_2011 = row['hm_2011']
                    variacao = row['variacao_hm']

                    tabela.append({
                        'nacionalidade_principal_id': nacionalidade_principal_id,
                        'nacionalidade_id': nacionalidade_id,
                        'posicao_ranking': posicao,
                        'populacao_2021': pop_2021,
                        'populacao_2011': pop_2011,
                        'percentagem_variacao': variacao
                    })

                    self.contadores_id['nacionalidade_principal_id'] += 1

        self.tabelas_normalizadas['NacionalidadePrincipal'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela NacionalidadePrincipal criada: {len(tabela)} registros")

    def criar_tabela_populacao_por_localidade(self):
        """Cria a tabela de relacionamento Popula√ß√£oPorLocalidade."""
        print("üèóÔ∏è  Criando tabela Popula√ß√£oPorLocalidade...")

        if 'q1_2_limpo' not in self.dados_originais:
            print("‚ùå Dados de localidade n√£o dispon√≠veis")
            return

        df_localidade = self.dados_originais['q1_2_limpo']
        tabela = []

        loc_to_id = self._criar_mapa_localidade_id()

        for _, row in df_localidade.iterrows():
            localidade = row['localidade']
            if localidade in loc_to_id:
                populacao_local_id = self.contadores_id['populacao_local_id']
                localidade_id = loc_to_id[localidade]

                tabela.append({
                    'populacao_local_id': populacao_local_id,
                    'localidade_id': localidade_id,
                    'populacao_id': 1,  # Refer√™ncia para 2021
                    'populacao_total': row['total_populacao'],
                    'populacao_portuguesa': row['populacao_portuguesa'],
                    'populacao_estrangeira': row['populacao_estrangeira'],
                    'apatridas': row['apatridas']
                })

                self.contadores_id['populacao_local_id'] += 1

        self.tabelas_normalizadas['PopulacaoPorLocalidade'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela Popula√ß√£oPorLocalidade criada: {len(tabela)} registros")

    def criar_tabela_distribuicao_geografica(self):
        """Cria a tabela DistribuicaoGeografica."""
        print("üèóÔ∏è  Criando tabela DistribuicaoGeografica...")

        if 'q1_2_limpo' not in self.dados_originais:
            print("‚ùå Dados de localidade n√£o dispon√≠veis")
            return

        df_localidade = self.dados_originais['q1_2_limpo']
        tabela = []

        nac_to_id = self._criar_mapa_nacionalidade_id()
        loc_to_id = self._criar_mapa_localidade_id()

        # Principais nacionalidades nas colunas do dataset
        nacionalidades_cols = [
            'Brasil', 'Angola', 'Cabo Verde', 'Reino Unido', 'Ucr√¢nia',
            'Fran√ßa', 'China', 'Guin√©-Bissau', '√çndia', 'Rom√™nia',
            'It√°lia', 'Nepal', 'Espanha', 'Alemanha', 'S√£o Tom√© e Pr√≠ncipe'
        ]

        for _, row in df_localidade.iterrows():
            localidade = row['localidade']
            if localidade in loc_to_id:
                localidade_id = loc_to_id[localidade]

                for nac in nacionalidades_cols:
                    if nac in row and nac in nac_to_id and row[nac] > 0:
                        distribuicao_geo_id = self.contadores_id['distribuicao_geo_id']
                        nacionalidade_id = nac_to_id[nac]

                        pop_nacional_local = row[nac]
                        pop_total_local = row['populacao_estrangeira']

                        # Concentra√ß√£o relativa
                        concentracao_rel = (pop_nacional_local / pop_total_local * 100) if pop_total_local > 0 else 0

                        # Determina dom√≠nio regional (simplificado)
                        dominio_regional = 'Alto' if concentracao_rel > 10 else 'M√©dio' if concentracao_rel > 5 else 'Baixo'

                        tabela.append({
                            'distribuicao_geo_id': distribuicao_geo_id,
                            'localidade_id': localidade_id,
                            'nacionalidade_id': nacionalidade_id,
                            'populacao_nacional_local': pop_nacional_local,
                            'concentracao_relativa': round(concentracao_rel, 2),
                            'dominio_regional': dominio_regional
                        })

                        self.contadores_id['distribuicao_geo_id'] += 1

        self.tabelas_normalizadas['DistribuicaoGeografica'] = pd.DataFrame(tabela)
        print(f"‚úÖ Tabela DistribuicaoGeografica criada: {len(tabela)} registros")

    # M√©todos auxiliares
    def _criar_mapa_nacionalidade_id(self):
        """Cria mapeamento entre nacionalidades e IDs."""
        if 'Nacionalidade' in self.tabelas_normalizadas:
            df = self.tabelas_normalizadas['Nacionalidade']
            return dict(zip(df['nome_nacionalidade'], df['nacionalidade_id']))
        return {}

    def _criar_mapa_localidade_id(self):
        """Cria mapeamento entre localidades e IDs."""
        if 'Localidade' in self.tabelas_normalizadas:
            df = self.tabelas_normalizadas['Localidade']
            return dict(zip(df['nome_localidade'], df['localidade_id']))
        return {}

    def _determinar_continente(self, nacionalidade):
        """Determina o continente baseado na nacionalidade."""
        nacionalidade = nacionalidade.lower()

        continentes = {
            'Europa': ['reino unido', 'fran√ßa', 'alemanha', 'it√°lia', 'espanha', 'rom√©nia', 'rom√™nia', 'ucr√¢nia'],
            'Am√©rica': ['brasil'],
            '√Åfrica': ['angola', 'cabo verde', 'guin√©-bissau', 's√£o tom√© e pr√≠ncipe'],
            '√Åsia': ['china', '√≠ndia', 'nepal'],
            'Outros': ['ap√°tridas']
        }

        for continente, paises in continentes.items():
            if any(pais in nacionalidade for pais in paises):
                return continente

        return 'Outros'

    def _criar_codigo_pais(self, nacionalidade):
        """Cria c√≥digo de pa√≠s simplificado."""
        codigos = {
            'Brasil': 'BR',
            'Angola': 'AO',
            'Cabo Verde': 'CV',
            'Reino Unido': 'GB',
            'Ucr√¢nia': 'UA',
            'Fran√ßa': 'FR',
            'China': 'CN',
            'Guin√©-Bissau': 'GW',
            '√çndia': 'IN',
            'Rom√™nia': 'RO',
            'Rom√©nia': 'RO',
            'It√°lia': 'IT',
            'Nepal': 'NP',
            'Espanha': 'ES',
            'Alemanha': 'DE',
            'S√£o Tom√© e Pr√≠ncipe': 'ST'
        }

        return codigos.get(nacionalidade, nacionalidade[:2].upper())

    def _determinar_nivel_administrativo(self, localidade):
        """Determina o n√≠vel administrativo da localidade."""
        localidade = localidade.lower()

        if 'portugal' in localidade:
            return 'Pa√≠s'
        elif 'continente' in localidade:
            return 'NUTS I'
        elif any(regiao in localidade for regiao in ['norte', 'centro', 'lisboa', 'alentejo', 'algarve', 'a√ßores', 'madeira']):
            if '√°rea metropolitana' in localidade or 'regi√£o aut√≥noma' in localidade:
                return 'NUTS II'
            else:
                return 'NUTS I'
        else:
            return 'Munic√≠pio'

    def _criar_codigo_regiao(self, localidade):
        """Cria c√≥digo da regi√£o."""
        regioes = {
            'Norte': 'N',
            'Centro': 'C',
            'Lisboa': 'LVT',
            'Alentejo': 'ALE',
            'Algarve': 'ALG',
            'A√ßores': 'AZ',
            'Madeira': 'MD'
        }

        for regiao, codigo in regioes.items():
            if regiao.lower() in localidade.lower():
                return codigo

        return 'OUTRO'

    def salvar_tabelas_csv(self, output_dir="3Ô∏è‚É£ Data Preparation"):
        """Salva todas as tabelas normalizadas como arquivos CSV."""
        print("üíæ Exportando tabelas para CSV...")

        # Cria diret√≥rio se n√£o existir
        Path(output_dir).mkdir(parents=True, exist_ok=True)

        arquivos_gerados = []

        for nome_tabela, df in self.tabelas_normalizadas.items():
            arquivo_csv = f"{output_dir}/{nome_tabela}.csv"

            try:
                df.to_csv(arquivo_csv, index=False, encoding='utf-8')
                arquivos_gerados.append(arquivo_csv)
                print(f"‚úÖ {nome_tabela}: {len(df)} registros ‚Üí {arquivo_csv}")
            except Exception as e:
                print(f"‚ùå Erro ao salvar {nome_tabela}: {e}")

        # Cria arquivo de √≠ndice
        self._criar_arquivo_indice(output_dir, arquivos_gerados)

        print(f"\nüìä Exporta√ß√£o conclu√≠da: {len(arquivos_gerados)} tabelas salvas em '{output_dir}'")
        return arquivos_gerados

    def _criar_arquivo_indice(self, output_dir, arquivos_gerados):
        """Cria arquivo de √≠ndice com informa√ß√µes sobre as tabelas."""
        print("üìã Criando arquivo de √≠ndice...")

        indice_info = {
            'arquivo': [],
            'tabela': [],
            'registros': [],
            'colunas': [],
            'descricao': []
        }

        descricoes = {
            'PopulacaoResidente': 'Popula√ß√£o residente total por ano de refer√™ncia',
            'Nacionalidade': 'Cadastro de nacionalidades com c√≥digos e continentes',
            'Localidade': 'Divis√µes administrativas (NUTS I/II/III/Munic√≠pios)',
            'Sexo': 'Classifica√ß√£o por sexo (HM/H/M)',
            'GrupoEtario': 'Grupos et√°rios padronizados',
            'PopulacaoPorNacionalidade': 'Popula√ß√£o por nacionalidade e ano',
            'PopulacaoPorGrupoEtario': 'Distribui√ß√£o et√°ria por nacionalidade',
            'EvolucaoTemporal': 'Evolu√ß√£o temporal 2011-2021 por nacionalidade',
            'NacionalidadePrincipal': 'Ranking das 15 principais nacionalidades',
            'PopulacaoPorLocalidade': 'Popula√ß√£o por divis√£o administrativa',
            'DistribuicaoGeografica': 'Concentra√ß√£o geogr√°fica por nacionalidade'
        }

        for arquivo in arquivos_gerados:
            nome_arquivo = Path(arquivo).name
            nome_tabela = nome_arquivo.replace('.csv', '')

            if nome_tabela in self.tabelas_normalizadas:
                df = self.tabelas_normalizadas[nome_tabela]

                indice_info['arquivo'].append(nome_arquivo)
                indice_info['tabela'].append(nome_tabela)
                indice_info['registros'].append(len(df))
                indice_info['colunas'].append(len(df.columns))
                indice_info['descricao'].append(descricoes.get(nome_tabela, 'Tabela do modelo relacional'))

        # Salva √≠ndice
        df_indice = pd.DataFrame(indice_info)
        arquivo_indice = f"{output_dir}/INDICE_TABELAS.csv"
        df_indice.to_csv(arquivo_indice, index=False, encoding='utf-8')
        print(f"‚úÖ √çndice criado: {arquivo_indice}")

    def gerar_relatorio_processamento(self):
        """Gera relat√≥rio final do processamento."""
        print("\n" + "="*60)
        print("üìä RELAT√ìRIO FINAL DE PROCESSAMENTO")
        print("="*60)

        print(f"\nüîç DADOS ORIGINAIS PROCESSADOS:")
        for nome, df in self.dados_originais.items():
            if isinstance(df, pd.DataFrame):
                print(f"  ‚Ä¢ {nome}: {len(df)} registros")

        print(f"\nüóÑÔ∏è  TABELAS NORMALIZADAS CRIADAS:")
        total_registros = 0
        for nome, df in self.tabelas_normalizadas.items():
            print(f"  ‚Ä¢ {nome}: {len(df)} registros")
            total_registros += len(df)

        print(f"\nüìà ESTAT√çSTICAS GERAIS:")
        print(f"  ‚Ä¢ Total de registros gerados: {total_registros:,}")
        print(f"  ‚Ä¢ Tabelas criadas: {len(self.tabelas_normalizadas)}")
        print(f"  ‚Ä¢ Estrutura normalizada: 3¬™ Forma Normal")

        print(f"\n‚úÖ MODELO ER IMPLEMENTADO COM SUCESSO!")
        print("="*60 + "\n")

def main():
    """Fun√ß√£o principal para executar todo o processamento."""
    print("üöÄ INICIANDO PROCESSAMENTO DOS DADOS INE - POPULA√á√ÉO ESTRANGEIRA")
    print("=" * 70)

    # Instancia o processador
    processador = ProcessadorDadosINE()

    try:
        # 1. Carrega dados originais
        processador.carregar_dados_originais()

        # 2. Limpa e processa dados
        processador.limpar_dados_nacionalidade_sexo()
        processador.limpar_dados_localidade()
        processador.limpar_dados_grupo_etario()

        print("\n" + "="*50)
        print("üèóÔ∏è  CRIANDO MODELO RELACIONAL NORMALIZADO")
        print("="*50)

        # 3. Cria tabelas principais
        processador.criar_tabela_populacao_residente()
        processador.criar_tabela_nacionalidade()
        processador.criar_tabela_localidade()
        processador.criar_tabela_sexo()
        processador.criar_tabela_grupo_etario()

        # 4. Cria tabelas de relacionamento
        processador.criar_tabela_populacao_por_nacionalidade()
        processador.criar_tabela_populacao_por_grupo_etario()
        processador.criar_tabela_evolucao_temporal()
        processador.criar_tabela_nacionalidade_principal()
        processador.criar_tabela_populacao_por_localidade()
        processador.criar_tabela_distribuicao_geografica()

        # 5. Exporta para CSV
        print("\n" + "="*50)
        print("üíæ EXPORTANDO DADOS PROCESSADOS")
        print("="*50)

        arquivos_gerados = processador.salvar_tabelas_csv()

        # 6. Gera relat√≥rio final
        processador.gerar_relatorio_processamento()

        return True

    except Exception as e:
        print(f"\n‚ùå ERRO DURANTE O PROCESSAMENTO: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    sucesso = main()
    if sucesso:
        print("üéâ Processamento conclu√≠do com sucesso!")
    else:
        print("üí• Processamento falhou. Verifique os logs acima.")